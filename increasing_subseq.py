import numpy as np

"""Задание: найти самую длинную подпоследовательность возрастающих чисел """


def get_len_longest_subseq(arr):


    """
    Функция для нахождения самой длинной подпоследовательности возратающих чисел
    Эта функция реализована без циклов, только с использованием numpy

    args:
        arr (list): массив с числами

    returns:
        int: длина подпоследовательости
    """


    # преобразовываем массив в numpy array для работы с функциями
    arr = np.array(arr)

    # проверка на пустой массив, если пуст, то возвращаем 0
    if len(arr) == 0:
        return 0

    # рассчитываем разности между соседними элементами
    # функция diff рассчитывает разность между сосед, возвращает массив, где каждый элмент - разность следующего и текущего
    # prepend нужно для обработки первого элемента, так как стоит -большое число, то последовательность будет всегда начинаться с него
    diffs = np.diff(arr, prepend=-1000000000000000)

    # маска для определения начала последовательностей
    # diffs <= 0 задает массив, в котором True на месте элементов меньших или равных нулю
    # (последовательность возрасатющих чисел остановилась) и False в противном случае (последовательность еще возрастает)
    # astype преобразовывает данные вв нужный формат (в данном случае в целочисленный, для хранения 4 байта, можно и больше 'int64')
    mask = (diffs <= 0).astype('int32')

    # вычисляем накопительный индекс групп
    # cumsum вычсляет сумму всех предыдущих элементов массива по текущий по определенному массиву
    group_ids = np.cumsum(mask)

    # для каждой группы находим её длину
    # unique возвращает уникальные элементы в массиве  (возвращает массив с уник элементами)
    # с помощью параметра return_counts=True функция возвращает еще и массив с количеством каждого уникального элемента
    unique_groups, counts = np.unique(group_ids, return_counts=True)

    # находим максимальную длину группы
    max_length = np.max(counts)

    return max_length






